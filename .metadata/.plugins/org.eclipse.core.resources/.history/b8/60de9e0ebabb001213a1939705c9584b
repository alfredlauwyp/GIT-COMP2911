import java.util.LinkedList;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.lang.StringBuffer;
import java.util.ArrayList;

/**
 * Implements Breadth First Search Algorithm
 * @author Hayden Smith
 *
 */
public class Asearch<E> {

	@SuppressWarnings("unchecked")
	public Asearch(Graph graph)
	{
		this.graph = graph;
		this.allNodes = graph.getNodes();
	}
	
	public LinkedList<E> findPath(E initialNodeObj, Comparator<AsearchNode<E>> comp)
	{
		
		
		
		// Establish path to take
		LinkedList<E> path = new LinkedList<E>();
		PriorityQueue<AsearchNode<E>> priorityQueue = new PriorityQueue<AsearchNode<E>>(INITIAL_QUEUE_CAPACITY, comp);
		
		if (allNodes.size() > 0)
		{
			AsearchNode<E> current = new AsearchNode<E>(initialNodeObj, 0, null)
			priorityQueue.add(current);
			
			boolean visitedAll = false;
			
			@SuppressWarnings("unchecked")
			LinkedList<E> edges = null;
			
			while (!priorityQueue.isEmpty() && !visitedAll)
			{
				current = priorityQueue.poll();
				if (current.getNumNodesVisited() < this.graph.getNumVertices())
				{
					current.addVisited(current);
				    
				    toAdd = graph.getNeighbours(current.getNodeObj());;
				    /**/for(Edge<Job> currentEdge : toAdd) {
				    	/**/Node<Job> node = this.graph.findNode(currentEdge.getTo().getContents());
				    	/**/AStarJobNode nodeToAdd = new AStarJobNode(node.getContents());
				    	/**/if(!current.visited(nodeToAdd))
				    	/**/{
				    		/**/double travelled = current.getTravelledDistance() + currentEdge.getWeight();
				    		/**/nodeToAdd.setTravelledDist(travelled);
				    		/**/nodeToAdd.setParent(current.getContents());
				    		/**/for(Node<Job> alreadyVisited : current.nodesVisited())
				    		/**/{
				    			/**/nodeToAdd.addVisited(alreadyVisited);
				    		/**/}
				    		/**/toVisit.add(nodeToAdd);
				    	/**/}
				    /**/}
				}
				else
				{
					visitedAll = true;
				}
			}
			
			if(current.getNumNodesVisited() == this.graph.getNumVertices()) {
				path = current.getNodesVisited();
			}
			return path;
			 
		}
		
	}
		
	private Graph graph;
	private ArrayList<ArrayList<E>> allNodes;
	private static final int INITIAL_QUEUE_CAPACITY = 100;

}
