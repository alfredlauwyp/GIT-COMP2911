import java.util.Iterator;
import java.util.LinkedList;
import java.util.Comparator;
import java.util.Collections;
import java.util.PriorityQueue;

/**
 * Implements Breadth First Search Algorithm
 * @author Hayden Smith
 *
 */
public class Asearch {

	public Asearch(DirectedStringGraph graph)
	{
		this.graph = graph;
		allNodes = graph.getNodeObjects();
	}
	
	public String findPath(String nodeStart, String nodeFinish, Comparator<AsearchNode> comp)
	{
		nodesVisited = new LinkedList<AsearchNode>();
		nodesToVisit = new PriorityQueue<AsearchNode>(100, comp);
		
		if (allNodes.size() > 0)
		{
			// Find starting node and add it to nodeToVisit
			DSGNode rootNode = graph.findNode(nodeStart);
			nodesToVisit.add(new AsearchNode(rootNode.getValue(), 0, rootNode.getStraightLineDistance(), null));
			
			// Get first node from AsearchNode nodes
			AsearchNode current = nodesToVisit.peek();
			
			System.out.println("DEBUG: " + current);
				int c = 0;
			while(!nodesToVisit.isEmpty() && !nodesVisited.contains(graph.findNode(nodeFinish)) && c < 5)
			{c++;
				/*Debug*/printNodes("\nnodesVisited", nodesVisited);
				/*Debug*/printQueue("nodesToVisit", nodesToVisit);
				current = nodesToVisit.poll();
				nodesVisited.add(current);		

				LinkedList<DSGEdge> toAdd = graph.findNode(current.getValue()).getEdges();									
				//Collections.sort(toAdd, comp);
								
				for (DSGEdge e : toAdd) 
				{
					String nodeName = e.getTo().getValue();
					int straightLineDistance = graph.findNode(nodeName).getStraightLineDistance();
					AsearchNode newNode = new AsearchNode(nodeName, 0, straightLineDistance, current);
					/*Debug*/System.out.println("Trying to add " + e.getTo().getValue());
					if (!nodesVisited.contains(e.getTo().getValue()) && !nodesToVisit.contains(e.getTo().getValue()))
					{
						
						nodesToVisit.add(newNode); // Where current = parent
					}
				}
			}
			
			/* Not concerned yet 
			if (nodesVisited.contains(graph.findNode(nodeFinish)))
			{				
				LinkedList<DSGNode> path = new LinkedList<DSGNode>();
				
				current	= graph.findNode(nodeFinish);
				path.addFirst(current);
				int index = nodesVisited.indexOf(current);
				DSGNode currentParent = parentVisited.get(index);
				while (current != currentParent)
				{
					current = currentParent;
					index = nodesVisited.indexOf(current);
					currentParent = parentVisited.get(index);
					path.addFirst(current);
				}
				
				printNodes("FINAL: ", path);
			}*/
			
			return null;
		}
		else
		{
			return "[X]";
		}
	}
	
	public AsearchNode findNode(String s) {
		DSGNode node = null;
		Iterator<DSGNode> nit = nodes.iterator();
		while (nit.hasNext() && node == null) {
			DSGNode next = nit.next();
			if (next.equals(s)) {
				node = next;
			}
		}
		return node;
	}
	
	private void printNodes(String preface, LinkedList<AsearchNode> list)
	{
		System.out.print(preface + ": .. ");
		for (AsearchNode item : list)
		{
			if (item != null) 
			{
				System.out.print(item.getValue());
				
			}
			else {
				System.out.print("NULL");
			}
			System.out.print("-");
		}
		System.out.println();
	}
	
	private void printQueue(String preface, PriorityQueue<AsearchNode> list)
	{
		System.out.print(preface + ": .. ");
		for (AsearchNode item : list)
		{
			if (item != null) 
			{
				System.out.print(item.getValue());
				
			}
			else {
				System.out.print("NULL");
			}
			System.out.print("-");
		}
		System.out.println();
	}
	
	private void printEdges1(String preface, LinkedList<DSGEdge> edges)
	{
		System.out.print(preface + ": .. ");
		for (DSGEdge item : edges)
		{
			System.out.print(item.toString());
			System.out.print(" || ");
		}
		System.out.println();
	}
	
	private void printEdges2(String preface, DSGNode node)
	{
		System.out.print(preface + ": .. ");
		String[] edges = this.graph.getEdges(node.getValue());
		for (int c = 0; c < edges.length; c++)
		{
			System.out.print(edges[c]);
			System.out.print(" || ");
		}
		System.out.println();
	}
	
	private DirectedStringGraph graph;
	private static LinkedList<DSGNode> allNodes;
	LinkedList<AsearchNode> nodesVisited;
	PriorityQueue<AsearchNode> nodesToVisit;

}
