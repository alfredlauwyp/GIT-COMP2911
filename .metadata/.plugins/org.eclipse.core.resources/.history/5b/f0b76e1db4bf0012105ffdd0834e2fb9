import java.io.FileNotFoundException;
import java.io.FileReader;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Scanner;
import java.lang.StringBuffer;
import java.util.LinkedList;

/**
 * Courier Delivery Class.
 * 
 * Given a list of Jobs with a "from" point and a "to" point
 *  from standard input, this class creates a graph, adds these
 *  points to the graph.
 * This class then performs an A* search on the graph to find 
 *  the minimal spanning path from one DualNode to
 *  another that passes through every DualNode
 * 
 * TODO: Set limitations
 * 
 * @author	Hayden Charles Smith, z3418003
 * 			Last modified: 15th May 2013
 */

public class CourierDelivery
{
	/**
	 * Main method for program
	 * @param args Arguments from standard input
	 */
	public static void main(String[] args)
	{
		Runtime runtime = Runtime.getRuntime();
	    runtime.gc();
	    long startMemory = (runtime.totalMemory() - runtime.freeMemory());
	    
		long start = System.currentTimeMillis();
		try
	    {
			Scanner userInput 					= new Scanner(new FileReader(args[0]));			
			DualPoint initialDualPoint 			= new JobPoint(0, 0, 0, 0);
			AdjacencyListGraph<DualPoint> graph = new AdjacencyListGraph<DualPoint>();
			
			while (userInput.hasNextLine())
			{
				String input[] = userInput.nextLine().split(" ");
				int fromX = Integer.parseInt(input[COODINATE_FROM_X]);
				int fromY = Integer.parseInt(input[COODINATE_FROM_Y]);
				int toX =	Integer.parseInt(input[COODINATE_TO_X]);
				int toY = 	Integer.parseInt(input[COODINATE_TO_Y]);
				graph.addNode(new JobPoint(fromX, fromY, toX, toY));
			}
			userInput.close();
			
			graph.addNode(initialDualPoint);			
			graph.connectAllNodes();
			asearch = new Asearch(graph);
			
			Comparator<SearchNode<DualPoint>> comparator = new Comparator<SearchNode<DualPoint>>()
		    { 
				public int compare(SearchNode<DualPoint> e1, SearchNode<DualPoint> e2)
				{
			    	if (e1.getHeuristicEstimate() > e2.getHeuristicEstimate()) return 1;
			    	if (e1.getHeuristicEstimate() < e2.getHeuristicEstimate()) return -1;
			    	else return 0;
				}
		    };
			speak(getPathPrintout(asearch.findMinimalSpanningPath(initialDualPoint, comparator))); 
	    }
	    catch (FileNotFoundException e)
	    {
	    	speak("FileNotFoundException: " + e.getMessage());
	    }
		catch (ArrayIndexOutOfBoundsException e)
		{
			speak("Please add a single parameter that is an input file");
		}
		
		System.out.println(((System.currentTimeMillis() - start)) + " mill seconds\n");
		
		runtime = Runtime.getRuntime();
	    // Run the garbage collector
	    //runtime.gc();
	    // Calculate the used memory
	    long endMemory = (runtime.totalMemory() - runtime.freeMemory());
	    System.out.println("Used memory is bytes: " + (endMemory - startMemory )/ 1024/1024 + "mb");
		
	}

	  public static void memory() {
	   
	    // Get the Java runtime
	    Runtime runtime = Runtime.getRuntime();
	    // Run the garbage collector
	    //runtime.gc();
	    // Calculate the used memory
	    long memory = runtime.totalMemory() - runtime.freeMemory();
	    System.out.println("Used memory is bytes: " + (memory / 1024) + "kb");
	  }

	
	/**
	 * Given a list of DualPoints, print out the number of DualPoints in this path,
	 *  the total distance covered by the DualPoints (internal and external),
	 *  and provide a summary of the movements (or carries) made between or within
	 *  these DualPoints
	 * @param path LinkedList of DualPoint's that constitute the path
	 * @return Single string that contains all necessary text
	 */
	private static String getPathPrintout(LinkedList<DualPoint> path)
	{
		StringBuffer printResult = new StringBuffer();
		StringBuffer nodePrintouts = new StringBuffer();
		int totalDistance = 0;
		int i = 0;
		for (; i < (path.size() - 1); i++)
		{
			DualPoint nodeLeft = path.get(i);
			DualPoint nodeRight = path.get(i + 1);
			nodePrintouts.append("Move from " + nodeLeft.getToX() + " " + nodeLeft.getToY() + " to " + nodeRight.getFromX() + " " + nodeRight.getFromY() + "\n");
			if (!nodeRight.isSamePoint())
			{
				nodePrintouts.append("Carry from " + nodeRight.getFromX() + " " + nodeRight.getFromY() + " to " + nodeRight.getToX() + " " + nodeRight.getToY() + "\n");
			}
			totalDistance += nodeLeft.getInternalDistance();
			totalDistance += nodeLeft.getExternalDistanceTo(nodeRight);
		}
		totalDistance += path.get(i).getInternalDistance();
		
		printResult.append(path.size() - 1 + " nodes explored\n");
		printResult.append("cost = " + totalDistance + "\n");
		printResult.append(nodePrintouts.toString());
		return printResult.toString();
	}
	
	/* May, 2013: For Assignment 2, do not print out move actions where the start and end points are the same; thus the output could consist of two (or more) carry actions in sequence. */

	/**
	 * Print a string to standard output
	 * @param printout String to print
	 */
	private static void speak(String printout)
	{
		if (!printout.equals(""))
		{
			System.out.print(printout);
		}
	}
	
	private static Asearch asearch;
	private static final int COODINATE_FROM_X = 1;
	private static final int COODINATE_FROM_Y = 2;
	private static final int COODINATE_TO_X = 4;
	private static final int COODINATE_TO_Y = 5;
	
}


