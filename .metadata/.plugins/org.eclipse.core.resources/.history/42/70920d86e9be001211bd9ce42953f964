import java.util.LinkedList;

/**
 * A* Search Node.
 * 
 * Acts as a node that operates in an A* search. This stores
 * 	a DualPoint object, and acts as a state space by storing
 * 	all previous nodes that have been visited upon reaching the
 *  current AsearchNode.
 * 
 * @author	Hayden Charles Smith, z3418003
 * 			Last modified: 15th May 2013
 */
public class AsearchNode implements SearchNode {

	/**
	 * Creates an AsearchNode object
	 * @param jobNode
	 * @param externalDistance
	 */
	public AsearchNode(DualPoint jobNode, int externalDistance)
	{
		this.nodeObj = jobNode;
		this.externalDistanceTravelled = externalDistance;
		this.visited = new LinkedList<SearchNode>();
	}
	
	/**
	 * Returns the DualPoint object contained within the AsearchNode
	 * @return The DualPoint object contained within the AsearchNode
	 */
	public DualPoint getNodeObj()
	{
		return this.nodeObj;
	}
	
	/**
	 * Adds an AsearchNode to the list of previously visited AsearchNode's
	 *  contained within this node
	 * @param newVisited AsearchNode to add to the visited list
	 */
	public void addVisited(SearchNode newVisited)
	{
		visited.addLast(newVisited);
	}
	
	/**
	 * Get the number of AsearchNodes that have been visited
	 * @return number of AsearchNodes previously visited
	 */
	public int getNumNodesVisited()
	{
		return visited.size();
	}
	
	/**
	 * Given a DualPoint, determines whether the current state
	 *  space has visited the node before
	 * @param otherNode DualPoint object to check if has been 
	 *  visited
	 * @return Whether the DualPoint object has been visited by
	 *  the current state space
	 */
	public boolean hasVisitedObj(DualPoint otherNode)
	{
		for (SearchNode node : visited)
		{
			if (node.getNodeObj().equals(otherNode))
			{
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Returns a list of AsearchNodes that have been visited
	 *  previously by the current node.
	 * @return LinkedList of AsearchNodes that have been visited
	 */
	public LinkedList<SearchNode> getNodesVisited()
	{
		LinkedList<SearchNode> path = new LinkedList<SearchNode>();
		for (SearchNode obj : visited)
		{
			path.add(obj);
		}
		return path;
	}
	
	/**
	 * Returns a list of AsearchNodes that have been visited
	 *  previously by the current node.
	 * @return LinkedList of AsearchNodes that have been visited
	 */
	public LinkedList<DualPoint> getNodeObjsVisited()
	{
		LinkedList<DualPoint> path = new LinkedList<DualPoint>();
		for (SearchNode obj : visited)
		{
			path.add(obj.getNodeObj());
		}
		return path;
	}
		
	/**
	 * Get the cumulative external distance the current state
	 *  space has travelled in order to reach it's current
	 *  location
	 * @return Cumulative external distance travelled to current 
	 *  state
	 */
	public int getExternalDistanceTravelled()
	{
		return this.externalDistanceTravelled;
	}
	
	/**
	 * Get the cumulative external and internal distance the
	 *  current state space has travelled in order to
	 *  reach it's current location
	 * @return Cumulative external and internal distance
	 *  travelled to current state
	 */
	public int getTotalDistanceTravelled()
	{
		int internalDistanceTravelled = 0;
		for (SearchNode eachNode : visited)
		{
			internalDistanceTravelled += eachNode.getNodeObj().getInternalDistance();
		}
		
		return this.externalDistanceTravelled + internalDistanceTravelled;
	}
	
	public int getEstimatedDistanceRemaining()
	{
		return this.estimatedDistanceRemaining;
	}
	
	public void setEstimatedDistanceRemaining(int val)
	{
		this.estimatedDistanceRemaining = val;
	}
	
	public int getHeuristicEstimate()
	{
		return this.estimatedDistanceRemaining + this.externalDistanceTravelled;
	}
	

	private LinkedList<SearchNode> visited;
	private DualPoint nodeObj;
	private int externalDistanceTravelled;
	private int estimatedDistanceRemaining;
	
}